(**************************************************************************)
(*       ___                                                              *)
(*      ||M||                                                             *)
(*      ||A||       A project by Andrea Asperti                           *)
(*      ||T||                                                             *)
(*      ||I||       Developers:                                           *)
(*      ||T||         The HELM team.                                      *)
(*      ||A||         http://helm.cs.unibo.it                             *)
(*      \   /                                                             *)
(*       \ /        This file is distributed under the terms of the       *)
(*        v         GNU General Public License Version 2                  *)
(*                                                                        *)
(**************************************************************************)

include "arithmetics/nat.ma".

inductive Variable: Type[0] â‰
 | variable: nat â†’ Variable
.

(*record variable instead*)

inductive Crumble : Type[0] â‰
 | CCrumble: Byte â†’ Environment â†’ Crumble 
 
with Byte : Type[0] â‰
 | CValue: Value â†’ Byte
 | AppValue: Value â†’ Value â†’ Byte

with Value : Type[0] â‰
 | var : Variable â†’ Value
 | lambda: Variable â†’ Crumble â†’ Value
  
with Environment : Type[0] â‰
 | Epsilon: Environment
 | Cons: Environment â†’ Substitution â†’ Environment
 
with Substitution: Type[0] â‰
 | subst: Variable â†’ Byte â†’ Substitution
.

coinductive pifTerm : Type[0] â‰
 | val_to_term: pifValue â†’ pifTerm
 | appl: pifTerm â†’ pifTerm â†’ pifTerm
 
with pifValue : Type[0] â‰
 | pvar: Variable â†’ pifValue
 | abstr: Variable â†’ pifTerm â†’ pifValue
 .
 
inductive pifSubst : Type[0] â‰
 | psubst: Variable â†’ pifTerm â†’ pifSubst
 .

notation "[ term 19 v â† term 19 b ]" non associative with precedence 90 for @{ 'substitution $v $b }.
interpretation "Substitution" 'substitution v b =(subst v b).

(*notation "âŒ© b break, e âŒª" non associative with precedence 90 for @{ 'ccrumble $b $e }.
*)
interpretation "Crumble creation" 'pair b e =(CCrumble b e).

notation "ğ›Œ x . y" right associative with precedence 40 for @{ 'lambda $x $y}.
interpretation "Abstraction" 'lambda x y = (lambda x y ).

notation "Î½ x" non associative with precedence 90 for @{ 'variable $x}.
interpretation "Variable contruction" 'variable x = (variable x).

lemma test_lambda0: âˆ€x: Variable. âˆ€y:Crumble. (ğ›Œx.y) = (lambda x y).
#x #y normalize // qed.

let rec push e a â‰  
 match e with
 [ Epsilon â‡’ Cons Epsilon a
 | Cons e1 a1 â‡’ Cons (push e1 a) (a1)
 ].
 
let rec e_size e on e â‰ 
 match e with
 [ Epsilon â‡’ O
 | Cons e s â‡’ S (e_size e)
 ]
. 
 
lemma push_test0: Cons (Cons Epsilon [Î½0 â† CValue (var Î½0)]) [Î½1 â† CValue (var Î½3)] = push ((Cons Epsilon [Î½1 â† CValue (var Î½3)])) ([Î½0 â† CValue (var Î½0)]).
normalize //. qed. 

let rec concat a b â‰ 
 match a with
 [ Epsilon â‡’ b
 | Cons e a' â‡’ match b with 
                      [ Epsilon â‡’ Cons e a'
                      | Cons e' b' â‡’ Cons (concat e (push e' a')) b'
                      ]
 ].

lemma concat_test0: concat (Cons (Cons Epsilon [Î½0 â† CValue (var Î½ 0)]) [Î½1 â† CValue (var \nu 3)]) (Cons (Cons Epsilon [Î½2 â† CValue (var \nu 3)]) [Î½1 â† CValue (var \nu 2)])=
(Cons (Cons (Cons (Cons Epsilon [Î½0 â† CValue (var \nu 0)]) [Î½1 â† CValue (var \nu 3)]) [Î½2 â† CValue (var \nu 3)]) [Î½1 â† CValue (var \nu 2)]).//. qed.

definition at: Crumble â†’ Environment â†’ Crumble â‰ Î»a,b.
match a with
[ CCrumble byte e  â‡’ CCrumble byte (concat e b) 
].

notation "hvbox(c @ e)" with precedence 35 for @{ 'at $c $e }.
interpretation "@ operation" 'at c e =(at c e).

definition v0: Value â‰ var Î½0.
definition b0: Byte â‰ CValue v0.
definition e0: Environment â‰ Epsilon.
definition e1: Environment â‰ Cons e0 [Î½0 â† b0].

definition v1: Value â‰ var \nu 1.
definition e2: Environment â‰ Cons e0 [Î½1 â† b0].

definition c0: Crumble â‰ âŒ© b0, e1 âŒª.
lemma test1:  e2 = e2. // qed.

lemma test2: c0 = CCrumble b0 e1. // qed.

lemma test3: (âŒ© b0, e1 âŒª @ e2) = âŒ© b0, concat e1 e2 âŒª.
// qed.